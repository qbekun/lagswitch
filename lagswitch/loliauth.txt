#include <iostream>
#include <windows.h>
#include <windivert.h>
#include <thread>
#include <atomic>
#include <chrono>
#include <string>
#include <iomanip>
#include <sstream>
#include <wininet.h>
#include <vector>
#include <comdef.h>
#include <Wbemidl.h>

#pragma comment(lib, "WinDivert.lib")
#pragma comment(lib, "wininet.lib")
#pragma comment(lib, "wbemuuid.lib")


// ==================== KEY SYSTEM ====================


// Prosty parser JSON na potrzeby tylko tablicy obiektów z pola "klucz"
struct KeyData {
    std::string klucz;
};

// Pobierz dane z URL (WinInet)
std::string DownloadUrl(const std::string& url) {
    std::string result;
    HINTERNET hInternet = InternetOpenA("MyAgent", INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
    if (!hInternet) return "";

    HINTERNET hConnect = InternetOpenUrlA(hInternet, url.c_str(), NULL, 0, INTERNET_FLAG_RELOAD, 0);
    if (!hConnect) {
        InternetCloseHandle(hInternet);
        return "";
    }

    char buffer[4096];
    DWORD bytesRead = 0;
    while (InternetReadFile(hConnect, buffer, sizeof(buffer) - 1, &bytesRead) && bytesRead) {
        buffer[bytesRead] = 0;
        result += buffer;
        bytesRead = 0;
    }

    InternetCloseHandle(hConnect);
    InternetCloseHandle(hInternet);

    return result;
}

// Prosty parser JSON - wyciąga klucze z pola "klucz" z tablicy JSON
std::vector<KeyData> ParseKeysJson(const std::string& json) {
    std::vector<KeyData> keys;
    size_t pos = 0;
    while ((pos = json.find("\"klucz\"", pos)) != std::string::npos) {
        size_t start = json.find(":", pos);
        if (start == std::string::npos) break;
        start = json.find("\"", start);
        if (start == std::string::npos) break;
        size_t end = json.find("\"", start + 1);
        if (end == std::string::npos) break;

        KeyData kd;
        kd.klucz = json.substr(start + 1, end - start - 1);
        keys.push_back(kd);
        pos = end + 1;
    }
    return keys;
}

// Pobierz UUID maszyny (HWID)
std::string GetMachineUUID() {
    HRESULT hres = CoInitializeEx(0, COINIT_MULTITHREADED);
    if (FAILED(hres)) return "";

    hres = CoInitializeSecurity(
        NULL, -1, NULL, NULL,
        RPC_C_AUTHN_LEVEL_DEFAULT,
        RPC_C_IMP_LEVEL_IMPERSONATE,
        NULL, EOAC_NONE, NULL);
    if (FAILED(hres)) {
        CoUninitialize();
        return "";
    }

    IWbemLocator* pLoc = NULL;
    hres = CoCreateInstance(
        CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
        IID_IWbemLocator, (LPVOID*)&pLoc);
    if (FAILED(hres)) {
        CoUninitialize();
        return "";
    }

    IWbemServices* pSvc = NULL;
    hres = pLoc->ConnectServer(
        _bstr_t(L"ROOT\\CIMV2"), NULL, NULL, 0, NULL, 0, 0, &pSvc);
    if (FAILED(hres)) {
        pLoc->Release();
        CoUninitialize();
        return "";
    }

    hres = CoSetProxyBlanket(
        pSvc,
        RPC_C_AUTHN_WINNT,
        RPC_C_AUTHZ_NONE,
        NULL,
        RPC_C_AUTHN_LEVEL_CALL,
        RPC_C_IMP_LEVEL_IMPERSONATE,
        NULL,
        EOAC_NONE);
    if (FAILED(hres)) {
        pSvc->Release();
        pLoc->Release();
        CoUninitialize();
        return "";
    }

    IEnumWbemClassObject* pEnumerator = NULL;
    hres = pSvc->ExecQuery(
        bstr_t("WQL"),
        bstr_t("SELECT UUID FROM Win32_ComputerSystemProduct"),
        WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
        NULL,
        &pEnumerator);
    if (FAILED(hres)) {
        pSvc->Release();
        pLoc->Release();
        CoUninitialize();
        return "";
    }

    IWbemClassObject* pclsObj = NULL;
    ULONG uReturn = 0;
    std::string uuid;

    if (pEnumerator) {
        HRESULT hr = pEnumerator->Next(WBEM_INFINITE, 1, &pclsObj, &uReturn);
        if (uReturn != 0) {
            VARIANT vtProp;
            hr = pclsObj->Get(L"UUID", 0, &vtProp, 0, 0);
            if (SUCCEEDED(hr) && vtProp.vt == VT_BSTR) {
                _bstr_t bstrUUID(vtProp.bstrVal);
                uuid = (const char*)bstrUUID;
            }
            VariantClear(&vtProp);
            pclsObj->Release();
        }
        pEnumerator->Release();
    }

    pSvc->Release();
    pLoc->Release();
    CoUninitialize();

    return uuid;
}

// Wysyła webhook na Discorda z IP, kluczem i HWID
void SendDiscordWebhook(const std::string& webhookUrl, const std::string& key, const std::string& ip, const std::string& hwid) {
    std::string jsonPayload =
        "{\"content\":\"Użyto klucza!\\n**Klucz:** " + key + "\\n**IP:** " + ip + "\\n**HWID:** " + hwid + "\"}";

    HINTERNET hInternet = InternetOpenA("DiscordWebhookBot", INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
    if (!hInternet) return;

    URL_COMPONENTSA urlComp = { 0 };
    urlComp.dwStructSize = sizeof(urlComp);
    char hostName[256] = { 0 };
    char urlPath[1024] = { 0 };
    urlComp.lpszHostName = hostName;
    urlComp.dwHostNameLength = sizeof(hostName);
    urlComp.lpszUrlPath = urlPath;
    urlComp.dwUrlPathLength = sizeof(urlPath);

    InternetCrackUrlA(webhookUrl.c_str(), 0, 0, &urlComp);

    HINTERNET hConnect = InternetConnectA(hInternet, hostName, INTERNET_DEFAULT_HTTPS_PORT, NULL, NULL, INTERNET_SERVICE_HTTP, 0, 0);
    if (!hConnect) {
        InternetCloseHandle(hInternet);
        return;
    }

    const char* acceptTypes[] = { "application/json", NULL };
    HINTERNET hRequest = HttpOpenRequestA(hConnect, "POST", urlPath, NULL, NULL, acceptTypes, INTERNET_FLAG_SECURE, 0);
    if (!hRequest) {
        InternetCloseHandle(hConnect);
        InternetCloseHandle(hInternet);
        return;
    }

    std::string headers = "Content-Type: application/json";

    BOOL bRequestSent = HttpSendRequestA(hRequest, headers.c_str(), (DWORD)headers.size(), (LPVOID)jsonPayload.c_str(), (DWORD)jsonPayload.size());

    HttpEndRequest(hRequest, NULL, 0, 0);
    InternetCloseHandle(hRequest);
    InternetCloseHandle(hConnect);
    InternetCloseHandle(hInternet);
}

// ==================== CONSTANTS & ENUMS ====================
namespace {
    constexpr int DEFAULT_BLOCK_TIME = 10; // seconds
    constexpr int KEY_DEBOUNCE_TIME = 300; // milliseconds
    constexpr int STATUS_UPDATE_INTERVAL = 50; // milliseconds
    constexpr int MAX_PACKET_SIZE = 65536;
}

enum class ConsoleColor {
    Black = 0,
    Blue = 1,
    Green = 2,
    Cyan = 3,
    Red = 4,
    Magenta = 5,
    Yellow = 6,
    White = 7,
    Bright = 8,
    Default = 7,
    StatusActive = Green | Bright,
    StatusInactive = Red | Bright,
    Warning = Yellow | Bright,
    Info = Cyan | Bright,
    Error = Red | Bright,
    Header = Magenta | Bright,
    Timer = Yellow | Bright
};

// ==================== GLOBAL VARIABLES ====================
namespace {
    std::atomic<bool> g_block_packets(false);
    std::atomic<bool> g_exit_program(false);
    HANDLE g_divert_handle = INVALID_HANDLE_VALUE;
    std::atomic<int> g_timer(0);
    std::atomic<UINT64> g_blocked_packets(0);
}

// ==================== FUNCTION DECLARATIONS ====================
bool IsAdmin();
void RestartAsAdmin();
void PacketThread();
void TimerThread();
void TogglePacketBlocking();
void Cleanup();
void SetConsoleColor(ConsoleColor color);
void PrintHeader();
void PrintStatus();
void PrintHelp();
void UpdateConsoleTitle();
std::string GetFormattedTime();
void DrawProgressBar(float progress, int width = 50);
void ClearScreenAndShowHeader();

// ==================== HELPER FUNCTIONS ====================
void SetConsoleColor(ConsoleColor color) {
    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), static_cast<WORD>(color));
}

std::string GetFormattedTime() {
    auto now = std::chrono::system_clock::now();
    auto in_time_t = std::chrono::system_clock::to_time_t(now);
    std::tm tm;
    localtime_s(&tm, &in_time_t);
    std::stringstream ss;
    ss << std::put_time(&tm, "%H:%M:%S");
    return ss.str();
}

void DrawProgressBar(float progress, int width) {
    std::cout << "[";
    int pos = static_cast<int>(width * progress);
    for (int i = 0; i < width; ++i) {
        std::cout << (i < pos ? "=" : (i == pos ? ">" : " "));
    }
    std::cout << "] " << int(progress * 100.0) << "%";
}

void UpdateConsoleTitle() {
    std::string title = "lolikuza.ovh - STATUS: ";
    title += (g_block_packets ? "ACTIVE" : "INACTIVE");
    if (g_block_packets) {
        title += " | TIME LEFT: " + std::to_string(g_timer) + "s";
        title += " | BLOCKED: " + std::to_string(g_blocked_packets);
    }
    SetConsoleTitleA(title.c_str());
}

void ClearStatusLine() {
    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    GetConsoleScreenBufferInfo(hConsole, &csbi);

    COORD coord = { 0, csbi.dwCursorPosition.Y };
    DWORD written;
    FillConsoleOutputCharacter(hConsole, ' ', csbi.dwSize.X, coord, &written);
    SetConsoleCursorPosition(hConsole, coord);
}

void ClearScreenAndShowHeader() {
    system("cls");
    PrintHeader();
    PrintHelp();
}

// ==================== CORE LOGIC ====================
bool IsAdmin() {
    BOOL is_admin = FALSE;
    SID_IDENTIFIER_AUTHORITY nt_authority = SECURITY_NT_AUTHORITY;
    PSID admin_group = nullptr;
    if (AllocateAndInitializeSid(&nt_authority, 2, SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &admin_group)) {
        CheckTokenMembership(nullptr, admin_group, &is_admin);
        FreeSid(admin_group);
    }
    return is_admin;
}

void RestartAsAdmin() {
    wchar_t path[MAX_PATH];
    if (GetModuleFileNameW(nullptr, path, MAX_PATH)) {
        ShellExecuteW(nullptr, L"runas", path, nullptr, nullptr, SW_SHOW);
    }
    std::exit(0);
}

bool OpenDivertHandle() {
    g_divert_handle = WinDivertOpen("outbound", WINDIVERT_LAYER_NETWORK, 0, 0);
    if (g_divert_handle == INVALID_HANDLE_VALUE) {
        SetConsoleColor(ConsoleColor::Error);
        std::cerr << "[" << GetFormattedTime() << "] ERROR: Failed to open WinDivert (Error: " << GetLastError() << ")" << std::endl;
        SetConsoleColor(ConsoleColor::Default);
        return false;
    }
    return true;
}

void PacketThread() {
    unsigned char packet[MAX_PACKET_SIZE];
    WINDIVERT_ADDRESS addr;
    UINT packet_len;
    while (g_block_packets && !g_exit_program) {
        if (WinDivertRecv(g_divert_handle, packet, sizeof(packet), &packet_len, &addr)) {
            g_blocked_packets++;
        }
        UpdateConsoleTitle();
        std::this_thread::sleep_for(std::chrono::milliseconds(1));
    }
}

void TimerThread() {
    while (g_timer > 0 && g_block_packets && !g_exit_program) {
        std::this_thread::sleep_for(std::chrono::seconds(1));
        g_timer--;
        UpdateConsoleTitle();
    }
    if (g_block_packets) {
        g_block_packets = false;
        SetConsoleColor(ConsoleColor::Warning);
        ClearScreenAndShowHeader();
        std::cout << "[" << GetFormattedTime() << "] [AUTO_PROTOCOL] Data flow restored" << std::endl;
        SetConsoleColor(ConsoleColor::Default);
        PrintStatus();
    }
}

void TogglePacketBlocking() {
    if (!g_block_packets) {
        if (!OpenDivertHandle()) return;
        g_block_packets = true;
        g_timer = DEFAULT_BLOCK_TIME;
        g_blocked_packets = 0;
        std::thread(PacketThread).detach();
        std::thread(TimerThread).detach();
        SetConsoleColor(ConsoleColor::StatusActive);
        ClearStatusLine();
        std::cout << "[" << GetFormattedTime() << "] [SYSTEM] Connection Void: ENGAGED" << std::endl;
    }
    else {
        g_block_packets = false;
        WinDivertClose(g_divert_handle);
        g_divert_handle = INVALID_HANDLE_VALUE;
        ClearScreenAndShowHeader();
        SetConsoleColor(ConsoleColor::StatusInactive);
        std::cout << "[" << GetFormattedTime() << "] [SYSTEM] Connection Void: TERMINATED" << std::endl;
    }
    SetConsoleColor(ConsoleColor::Default);
    UpdateConsoleTitle();
    PrintStatus();
}

void Cleanup() {
    g_exit_program = true;
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    if (g_divert_handle != INVALID_HANDLE_VALUE) {
        WinDivertClose(g_divert_handle);
        g_divert_handle = INVALID_HANDLE_VALUE;
    }
    g_block_packets = false;
    UpdateConsoleTitle();
}

// ==================== UI ====================
void PrintHeader() {
    SetConsoleColor(ConsoleColor::Header);
    std::cout << R"(
ㅤㅤㅤㅤㅤㅤㅤㅤ⠀⢮⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧
ㅤㅤㅤㅤㅤㅤㅤ⠀⢘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠠
ㅤㅤㅤㅤㅤㅤㅤ⠀⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇
ㅤㅤㅤㅤㅤㅤㅤ⠀⢸⣿⣿⣿⣿⣿⡿⣽⠇⢸⣿⣿⣿⣿⣿⣿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠆
ㅤㅤㅤㅤㅤㅤㅤ⠀⠈⠘⢿⣿⡿⢿⣇⣹⠇⠨⢎⣿⢿⣿⣿⡿⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃
ㅤㅤㅤㅤㅤㅤㅤ⠀⠀⠀⢸⣿⡇⣷⣤⣩⡃⠘⠈⢸⠉⡤⣿⣅⡐⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣟⠆
ㅤㅤㅤㅤㅤㅤㅤ⠀⠀⠀⠈⠃⢿⠘⠛⠛⠃⠀⠀⠀⠀⠀⢿⣤⣉⡓⠻⣿⣿⣿⣿⣿⡳⣿⣿⡿⠀
ㅤㅤㅤㅤㅤㅤㅤ⠀⠀⠀⠀⠀⠈⣆⠀⠐⠀⢀⠀⠀⠀⠀⠈⠛⠿⠛⠁⠁⣿⣿⣿⣏⣽⣿⡟⠇⠀
ㅤㅤㅤㅤㅤㅤㅤ⠀⠀⠀⠀⠀⠀⠈⢦⡀⢀⠯⣤⠀⠀⠀⠀⠀⠀⠀⠀⢨⣿⣿⡿⠿⠿⠻⠁⠀⠀
ㅤㅤㅤㅤㅤㅤㅤ⠀⠀⠀⠀⠀⠀⠀⠀⢹⣄⡀⠀⠄⠀⡀⠀⠀⠀⢀⣠⢷⣿⣿⣿⡆⠀⠀⠀⠀⠀
ㅤㅤㅤㅤㅤㅤㅤ⠀⠀⠀⠀⠀⢀⣠⣶⣿⣿⠑⢤⣈⣄⣤⣤⢶⣟⠯⠃⢹⣿⣿⣿⣷⣄⠀⠀⠀⠀
ㅤㅤㅤㅤㅤㅤㅤ⠀⢀⣠⣴⣾⣿⣿⣿⣿⡏⢀⣦⣿⡞⠓⠋⠉⠀⠀⠀⢸⣿⣿⣿⣿⣿⣷⣄⠀⠀
ㅤㅤㅤㅤㅤㅤㅤ⣶⣿⣿⣿⣿⣿⣿⣿⣿⣷⣿⣿⣿⣷⡀⠂⠄⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⣯⣧⡀
ㅤㅤㅤㅤㅤㅤㅤ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⢀⠀⣀⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶
ㅤㅤㅤㅤㅤㅤㅤ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣄⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
ㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤlolikuza.ovh
)" << std::endl;
    SetConsoleColor(ConsoleColor::Default);
}

void PrintStatus() {
    static bool firstRun = true;
    if (firstRun) {
        firstRun = false;
        return;
    }

    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    GetConsoleScreenBufferInfo(hConsole, &csbi);

    COORD coord = { 0, csbi.dwCursorPosition.Y };
    SetConsoleCursorPosition(hConsole, coord);

    SetConsoleColor(g_block_packets ? ConsoleColor::StatusActive : ConsoleColor::StatusInactive);
    std::cout << "[" << GetFormattedTime() << "] LAYER_STATUS::" << (g_block_packets ? "\x1b[32m[ACTIVE]\x1b[0m" : "\x1b[31m[STANDBY]\x1b[0m");

    if (g_block_packets) {
        SetConsoleColor(ConsoleColor::Timer);
        std::cout << " || SYNC_DECAY:" << std::setw(2) << g_timer << "s";
        std::cout << " || PACKETS_TERMINATED:" << g_blocked_packets << " ";
        float progress = 1.0f - (static_cast<float>(g_timer) / DEFAULT_BLOCK_TIME);
        DrawProgressBar(progress, 20);
    }

    std::cout << std::flush;
    SetConsoleColor(ConsoleColor::Default);
}

void PrintHelp() {
    SetConsoleColor(ConsoleColor::Info);
    std::cout << "\n[SYSTEM_INTERFACE]" << std::endl;
    std::cout << "  >> CAPS_LOCK_KEY: Toggle data firewall" << std::endl;
    std::cout << "  >> SYS_READY" << std::endl;
    SetConsoleColor(ConsoleColor::Default);
}

typedef HANDLE(WINAPI* WinDivertOpen_t)(const char*, INT64, INT, UINT64);
typedef BOOL(WINAPI* WinDivertClose_t)(HANDLE);

// ==================== MAIN ====================
int main() {

    if (!IsAdmin()) {
        SetConsoleColor(ConsoleColor::Warning);
        std::cout << "[" << GetFormattedTime() << "] [WARNING] Elevating to security layer..z." << std::endl;
        SetConsoleColor(ConsoleColor::Default);
        RestartAsAdmin();
        return 0;
    }
    std::string keysJson = DownloadUrl("https://raw.githubusercontent.com/qbekun/qbekun/refs/heads/main/other/loli.json");
    if (keysJson.empty()) {
        return 1;
    }

    std::vector<KeyData> keys = ParseKeysJson(keysJson);
    if (keys.empty()) {
        return 1;
    }

    std::cout << "[" << GetFormattedTime() << "] >>//AUTH_REQUIRED//Enter_Key_Sequence: ";
    std::string userKey;
    std::getline(std::cin, userKey);

    bool keyValid = false;
    for (const auto& k : keys) {
        if (k.klucz == userKey) {
            keyValid = true;
            break;
        }
    }

    if (!keyValid) {
        std::cout << "[" << GetFormattedTime() << "] >>//ACCESS_DENIED//Invalid_Crypt_Key\n";
        std::string ip = DownloadUrl("https://api.ipify.org");
        if (ip.empty()) ip = "Nieznane IP";

        std::string hwid = GetMachineUUID();
        if (hwid.empty()) hwid = "Nieznane HWID";

        // Wyślij powiadomienie na Discord webhook
        const std::string webhookUrl = "https://discord.com/api/webhooks/1384956423561023488/ECAawBUhBQnmZ6tn1v8-xYcPeGeOU5gYNmmz_ht2N2P6umqwxnNFVX8MKM1lEYcsAzLf";
        SendDiscordWebhook(webhookUrl, userKey, ip, hwid);
        return 1;
    }

    std::string ip = DownloadUrl("https://api.ipify.org");
    if (ip.empty()) ip = "Nieznane IP";

    std::string hwid = GetMachineUUID();
    if (hwid.empty()) hwid = "Nieznane HWID";

    std::cout << "[" << GetFormattedTime() << "] >>//ACCESS_GRANTED//Terminal_Link_Established\n";

    // Wyślij powiadomienie na Discord webhook
    const std::string webhookUrl = "https://discord.com/api/webhooks/1384956112637394964/5Z4kXTEpTJpNEHtQwE1Uy7Olwc1nJGHxU-4uHiH98mo2Wp4pAvHjwyKuwOie6pwJdiKy";
    SendDiscordWebhook(webhookUrl, userKey, ip, hwid);

    ClearScreenAndShowHeader();
    UpdateConsoleTitle();
    PrintStatus();

    while (!g_exit_program) {
        if (GetAsyncKeyState(VK_CAPITAL) & 0x8000) {
            TogglePacketBlocking();
            std::this_thread::sleep_for(std::chrono::milliseconds(KEY_DEBOUNCE_TIME));
        }
        PrintStatus();
        std::this_thread::sleep_for(std::chrono::milliseconds(STATUS_UPDATE_INTERVAL));
    }

    Cleanup();
    SetConsoleColor(ConsoleColor::Info);
    std::cout << "\n[" << GetFormattedTime() << "] [SYSTEM] Disconnecting from network layer..." << std::endl;
    SetConsoleColor(ConsoleColor::Default);
    return 0;
}